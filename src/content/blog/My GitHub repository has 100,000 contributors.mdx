---
description: A parody of "everything" from npm
---

{/* cspell:ignore ineffectuating nmap irregardlessly */}

Your eyes don’t deceive you. You can check right now: my [GitHub repository](https://github.com/ArhanChaudhary/everyone) has 100,000 contributors.

Before I explain the how and the why, we first need to go back to a few weeks ago. I was routinely moving around some configuration files, and I accidentally swapped my `~/.gitconfig` file with that of my alternate account. When I pushed to one of my repositories, I was surprised to notice that my alt account was added as a contributor! Its rendered profile picture, username, and hyperlink — all neatly displayed under "Contributors". There's a good chance you've already seen something [similar](https://github.com/Amog-OS/AmogOS/commit/0bb33e31e2a529bfd13c6013d1ad2dffa2485b61) to this; it isn't hard or particularly new to fake a commit from another user. But my curiosity was sparked. In my mind, the next logical question to ask was: how many contributors could I fake? And thereafter: could I get to exactly 100,000 contributors?

*(Before continuing, I would like to point out that users can sign their commits to cryptographically verify their identity, ineffectuating impersonation. Even then, impersonation is against GitHub's [Acceptable Use Policies](https://docs.github.com/en/site-policy/acceptable-use-policies/github-impersonation). Please be wary.)*

I wasn't trying to make 100,000 commits faking a different GitHub user each time, so I did some research and found a more efficient way. If you add two new lines under a commit message, you can co-author GitHub users with their username and email address as shown.

```bash
$ git commit -m "Refactor usability tests.
>
>
Co-authored-by: NAME <NAME@EXAMPLE.COM>
Co-authored-by: ANOTHER-NAME <ANOTHER-NAME@EXAMPLE.COM>"
```

And so on, with seemingly no co-author limit. Luckily for my case, each one is added as a contributor! Armed with this knowledge, I began to formulate a plan.

# The plan

Manually adding this many GitHub users to a commit message obviously isn’t practical. I needed to write an API scraper, and a quick check of GitHub's [policies](https://bounty.github.com/#legal_safe_harbor) affirms I'm allowed to do this if I'm not too excessive.

> We do allow the use of automated tools so long as they do not produce excessive amounts of traffic. For example, running one nmap scan against one host is allowed, but sending 65,000 requests in two minutes using Burp Suite Intruder is excessive.

So, I got to brainstorming. The most important conceptual hurdle was figuring out how to get a user's email address, as you can't co-author a user without it. The problem was, even if a user makes their email address address publicly visible on their profile, the GitHub API doesn't reliably expose it*. Surprisingly, there is a very well-known way to circumvent this and find almost anyone's email address on GitHub.

Simply navigate to any commit authored by a user on GitHub and append `.patch` to the commit's url. Et voilà! The second line from the top enclosed within angle brackets lies their email address, in full form and glory. It sounds concerning that this type of information is so easy to access, but if you think about it, emails are made public for a reason. Attribution and contact are pretty important from an open source perspective.

With these types of technical projects that work with big data, social conduct should be taken seriously. I don't want to end up in a similar situation to [this guy](https://github.com/EpicGames/Signup/pull/24) and piss off 100,000 people by publicly leaking their email addresses. So, I decided to only co-author private email addresses that are only valid within GitHub.

Admittedly, a small amount of real email addresses were committed at the beginning, but only for testing purposes. I believe that this amount is small enough to be insignificant and inconsequential.

How would I find 100,000 users? GitHub provides a Search API for querying for users, but this was problematic because it had a rate limit of... wait for it... 30 requests per hour. Ba dum, tss! Instead, I opted to use the API endpoint for followers to feed my API scraper its users, which had a marginally higher rate limit I could work with.

Putting everything together, my API scraper will:

1. First use the Search API to find the most followed users on GitHub
2. Use the followers API endpoint to loop through each user's followers *(In retrospect, another approach could be a web crawling algorithm)*
3. Use the "hack" as described earlier to find each follower's email address
4. Filter each email address for private email addresses only valid within GitHub and format the co-author message

*The situation here is strange. For reasons unknown, the GitHub GraphQL API straight up doesn't expose the majority of users' public emails... UNLESS you use the GitHub REST API; in which case only this works... UNLESS you use the [GitHub GraphQL explorer](https://docs.github.com/en/graphql/overview/explorer) which seems to work with perfect accuracy. It's really weird.

# The Script

I decided to write my API scraper in JavaScript so I could utilize [octokit.js](https://github.com/octokit/octokit.js), which provided useful built-in functionality such as throttling and retrying. I also decided to use the GitHub GraphQL API instead of the GitHub REST API. Initial testing showed that the GraphQL API had the potential to be orders of magnitudes more efficient, especially given the fact you can batch multiple queries in a single request.

partially verified
1500/5000 Scarily efficient

Error log


11 variants of linux:

https://github.com/DAMON-BIN/linux
https://github.com/zhijie-zhang/rdma
https://github.com/xlab-uiuc/seccomp-ebpf-upstream
https://github.com/summ9919/motorola_esp_kernel_19.1
https://github.com/dandelion64-Archives/android_kernel_mediatek_mt6765g
https://github.com/MyTimeToShine777/msm-4.14
https://github.com/lu9944/KernelSU_msm-4.14
https://github.com/selurvedu/msm-4.14_kernel_xiaomi_laurel_sprout
https://github.com/Sailfy/android_kernel_redmi_mt6785
https://github.com/Sm680-Development/kernel_motorola_sm6225
https://github.com/MK-986123/kernel_samsung_sm8550

transition into:

The mystery of "MDQ6VXNlcjUxODE1MDgy"

`history(first: 1, author: {id: "MDQ6VXNlcjUxODE1MDgy"})` always crashes

The mystery of MyWebsite

https://github.com/Fonseca004/MyWebsite
timezone is wrong

commit 1955381b566e4e161b969e4d566e35b2caacacc9 (HEAD -> main, origin/main, origin/HEAD)
Author: Fonseca `<...>`
Date:   Fri Dec 2 10:14:22 3194 +25627400

scp root@147.182.243.54:everyone/results.txt .
git commit --allow-empty -F results.txt

Implications

spoof pair extraordinaire

Does this even matter?

Nope, nada. Not at all. But I think that’s what makes this accident of an art project so beautiful. In the words of Yusuke Endoh, "[Why not? Why not? Why not?](https://github.com/mame/quine-relay/issues/11)" I would be lying if I said I didn’t learn anything.
A fireplace of ghosts, a bizarre pit stop of GitHub users.

good chance people will hate on this project https://iliana.fyi/blog/everything-that-lives-is-designed-to-end/

Phew! Not bad for my second blog, don’t you think? Until next time!
