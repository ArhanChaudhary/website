import Example from "../../assets/blog/The Generativity Pattern in Rust/permutation example.typ";

{/* cspell:ignore typestate generativity newtype Rustaceans Rovynak rubiks */}

Thank you to [Henry Rovynak](https://hrovnyak.gitlab.io/) for invaluable feedback and peer-reviewing this article!

The *generativity pattern* in Rust is a combination of [typestate](https://cliffle.com/blog/rust-typestate/) and [GhostCell](https://plv.mpi-sws.org/rustbelt/ghostcell/), techniques that eliminate runtime overhead through compile-time safety guarantees. This pattern is not commonplace; its usage warrants a specific set of circumstances. Aside from thinly spread literature, I haven't a found a detailed analysis of this pattern online. So, I want to take the opportunity to introduce the concept of lifetime branding through a realistic example.

We are going to gradually build up a full picture of the "what" and the "why." Let's take the role of a crate author about permutations. We want to investigate the [composition](https://en.wikipedia.org/wiki/Permutation_group#Composition_of_permutations–the_group_product) of permutations. This can be expressed nicely visually.

<Example />

The permutation `b` defines the remapping of the elements from permutation `a`. Pretty simple. Notice that permutation composition is only possible under the following three conditions:

1. `a` and `b` have the same length.
1. Each element from `b` must be less than or equal to the length.
1. Each element from `b` is unique.

Our library is general-purpose, so it is important to handle these error cases. Here is the simplest way to do that.

```rust
// We provide a `compose_into` function in case the caller already has
// a permutation preallocated. (This is good practice IMO).
pub fn compose_into(a: &[usize], b: &[usize], into: &mut [usize]) -> Result<(), &'static str> {
    if a.len() != b.len() || b.len() != into.len() {
        return Err("Permutations must have the same length");
    }
    let mut seen_b = vec![false; a.len()];
    let mut seen_a = vec![false; b.len()];
    for (into_value, &b_value) in into.iter_mut().zip(b) {
        if *seen_b
            .get(b_value)
            .ok_or("B contains an element greater than the length")?
        {
            return Err("B contains repeated elements");
        }
        seen_b[b_value] = true;

        let a_value = a[b_value];
        if *seen_a
            .get(a_value)
            .ok_or("A contains an element greater than the length")?
        {
            return Err("A contains repeated elements");
        }
        seen_a[a_value] = true;

        *into_value = a_value;
    }
    Ok(())
}
```

Good on you if this made you uneasy. Rust allows us to guarantee at the type level that `a` and `b` are valid permutations, using the [newtype](https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html) design pattern.

```rust
pub struct Permutation(Box<[usize]>);

impl Permutation {
    pub fn from_mapping(mapping: Vec<usize>) -> Result<Self, String> {
        // ... validate that `mapping` is a valid permutation
        Ok(Permutation(mapping.into_boxed_slice()))
    }

    pub fn compose_into(&self, b: &Permutation, into: &mut Permutation) -> Result<(), String> {
        if self.0.len() != into.0.len() || b.0.len() != into.0.len() {
            return Err("Permutations must have the same length".to_string());
        }
        for (into_value, &b_value) in into.0.iter_mut().zip(&b.0) {
            // SAFETY: `b` is guaranteed to be a valid permutation
            // whose elements can index `self`
            *into_value = unsafe { *self.0.get_unchecked(b_value) };
        }
        Ok(())
    }

    pub fn compose(&self, b: &Permutation) -> Result<Permutation, String> {
        let mut result = Permutation(vec![0; self.0.len()].into_boxed_slice());
        self.compose_into(b, &mut result)?;
        Ok(result)
    }
}
```

The newtype pattern is more useful than just for getting around the orphan rule. We restrict construction of `Permutation` to the `from_mapping` method, which returns an error if `mapping` is not a valid permutation. That means that if we have an instance of `Permutation`, we don't have to worry about its mapping being potentially invalid before using it. Rustaceans describe type-level guarantees like this by saying an *invariant* of `Permutation` is that it represents a valid permutation. Composing two permutations upholds this invariant, so we expose `compose` to create a new `Permutation` from existing ones.

This code is a major improvement! It is simple, easy to use, and it provides reasonable errors. However, a closer examination reveals some problems:

- Every call to our composition function spends time performing a length check. Our example is simplistic so it happens to be cheap, but this type of check may require more expensive logic in a practical scenario.
- Returning a `Result` forces the caller to be prepared to handle the error case. Library users might be able to guarantee that the length checks will pass, which would make the error handling an annoyance rather than helpful.

Yes, these aren't *important* problems per se, but they are still inconveniences to be aware of.

We now want to extend our library to model a [permutation group](https://en.wikipedia.org/wiki/Permutation_group), or just a representation of a bunch of permutations. In a permutation group, every permutation can be written as a sequence of compositions of base permutations. For example, the manipulations of the Rubik's Cube form a permutation group. Its base permutations are the six face rotations. Therefore, every possible state on the Rubik's cube can be reached from a combination of those face rotations.

<ContentImage src={rubiksCube} width="350" alt="The solved Rubik's cube" />

It follows that if you compose two elements in a permutation group, the resulting permutation will also be an element of that group.

A reasonable data structure for permutation groups looks like this.

```rust
pub struct PermGroup {
    base_permutation_length: usize,
    base_permutations: Vec<Permutation>,
}

impl PermGroup {
    pub fn new(
        base_permutation_length: usize,
        base_permutation_mappings: Vec<Vec<usize>>,
    ) -> Result<Self, String> {
        // ... validate that each mapping is a valid
        // permutation of the given length
        // (remember that permutations can only be
        // composed if they have the same length)
        Ok(Self {
            base_permutation_length,
            base_permutations: base_permutation_mappings
                .into_iter()
                .map(Permutation::from_mapping)
                .collect::<Result<_, _>>()?,
        })
    }

    pub fn base_permutations(&self) -> &[Permutation] {
        &self.base_permutations
    }
}
```

Your *inner Ferris* awakens. With the annoyances of our last iteration freshly in memory, you ask yourself: can we perform the length check just once during the creation of the permutation group, and avoid it entirely in our permutation composition function? Can we tweak our composition function to only operate on permutations from the same permutation group?

```rust
pub struct Permutation(Box<[usize]>);

impl Permutation {
    // ...
    fn compose_into(&self, b: &Permutation, into: &mut Permutation) {
        for i in 0..into.0.len() {
            unsafe {
                *into.0.get_unchecked_mut(i) = *self.0.get_unchecked(*b.0.get_unchecked(i));
            }
        }
    }
    // ...
}
```

All of a sudden, we've opened up an unsafety hole! We implicitly assumed that the permutations to compose were from the same permutation group. This is not necessarily true—what if a library user composes two base permutations from different permutation groups? This operation is obviously nonsensical, but it does not change the fact that it is still *our* responsibility, as the crate author, the safe functions we provide can never cause undefined behavior. If we wanted to validate our assumption, checking that a permutation is a member of a permutation group is a very expensive operation; this is the "practical scenario" I mentioned beforehand.

SCRATCH NOTES:

The fundamental problem is that the invariant of `Permutation` guarantees it is a valid permutation, but not that it is associated with a specific `PermGroup`.

what if we wanted to make it a trait

What would really be nice is an *infallible* composition operation; one that we can guarantee is correct at the type level.
It's useful anytime you want to guarantee that two values come from or refer to the same source

We validate *upfront* that a set of permutations

BrandedVec

Does not use a closure

We need to make

Generativity in the wild:
https://docs.rs/async-local/6.0.2/src/async_local/lib.rs.html#1-354
