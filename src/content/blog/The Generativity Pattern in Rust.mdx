import PermutationExample from "../../assets/blog/The Generativity Pattern in Rust/permutation example.typ";

{/* cspell:ignore typestate generativity newtype Rustaceans Rovynak rubiks */}

*This article was written in conjunction with [Henry Rovynak](https://hrovnyak.gitlab.io/). I thank Henry for his invaluable feedback and peer-review.*

The *generativity pattern* in Rust is a combination of [typestate](https://cliffle.com/blog/rust-typestate/) and [GhostCell](https://plv.mpi-sws.org/rustbelt/ghostcell/), techniques that eliminate runtime overhead through compile-time safety guarantees. This pattern is not commonplace; its usage warrants a specific set of circumstances. Aside from thinly spread literature, I haven't a found an accessible analysis of this pattern online. So, I want to take the opportunity to introduce the concept of lifetime branding through a realistic example.

We are going to gradually build up a full picture of the "what" and the "why." Let's take the role of a crate author about permutations. We want to investigate the [composition](https://en.wikipedia.org/wiki/Permutation_group#Composition_of_permutations–the_group_product) of permutations. This can be expressed nicely visually.

<PermutationExample />

The permutation `b` defines the remapping of the elements from permutation `a`. Pretty simple. Notice that permutation composition is only possible under the following three conditions:

1. `a` and `b` have the same length.
2. Each element from `b` must be less than or equal to the length.
3. Each element from `b` is unique.

Our library is general-purpose, so it is important to handle these error cases. Here is the simplest way to do that.

```rust
// We provide a `compose_into` function in case the caller already has
// a permutation preallocated. (This is good practice IMO).
pub fn compose_into(a: &[usize], b: &[usize], into: &mut [usize]) -> Result<(), &'static str> {
    if a.len() != b.len() || b.len() != into.len() {
        return Err("Permutations must have the same length");
    }
    let mut seen_b = vec![false; a.len()];
    let mut seen_a = vec![false; b.len()];
    for (into_value, &b_value) in into.iter_mut().zip(b) {
        if *seen_b
            .get(b_value)
            .ok_or("B contains an element greater than the length")?
        {
            return Err("B contains repeated elements");
        }
        seen_b[b_value] = true;

        let a_value = a[b_value];
        if *seen_a
            .get(a_value)
            .ok_or("A contains an element greater than the length")?
        {
            return Err("A contains repeated elements");
        }
        seen_a[a_value] = true;

        *into_value = a_value;
    }
    Ok(())
}
```

Good on you if this made you uneasy. Rust allows us to guarantee at the type level that `a` and `b` are valid permutations, using the [newtype](https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html) design pattern.

```rust
pub struct Permutation(Box<[usize]>);

impl Permutation {
    pub fn from_mapping(mapping: Vec<usize>) -> Result<Self, &'static str> {
        // ... validate that `mapping` is a valid permutation
        Ok(Permutation(mapping.into_boxed_slice()))
    }

    pub fn compose_into(&self, b: &Permutation, into: &mut Permutation) -> Result<(), &'static str> {
        if self.0.len() != into.0.len() || b.0.len() != into.0.len() {
            return Err("Permutations must have the same length");
        }
        for (into_value, &b_value) in into.0.iter_mut().zip(&b.0) {
            // SAFETY: `b` is guaranteed to be a valid permutation
            // whose elements can index `self`
            *into_value = unsafe { *self.0.get_unchecked(b_value) };
        }
        Ok(())
    }

    pub fn compose(&self, b: &Permutation) -> Result<Permutation, &'static str> {
        let mut result = Permutation(vec![0; self.0.len()].into_boxed_slice());
        self.compose_into(b, &mut result)?;
        Ok(result)
    }
}
```

The newtype pattern is more useful than just for getting around the orphan rule. We restrict construction of `Permutation` to the `from_mapping` method, which returns an error if the input is not a valid permutation. That means if we have an instance of `Permutation`, we don't have to worry about its mapping being potentially invalid before using it. Rustaceans describe type-level guarantees like this by saying an *invariant* of `Permutation` is that it represents a valid permutation. Composing two permutations upholds this invariant, so we expose `compose` to create a new `Permutation` from existing ones.

This code is a major improvement! It is simple, easy to use, and it provides reasonable errors. However, a closer examination reveals some problems:

- Every call to our composition function spends time performing a length check. Our example is simplistic so it happens to be cheap, but this type of check may require more expensive logic in a practical scenario.
- Returning a `Result` forces the caller to be prepared to handle the error case. Library users might be able to guarantee that the length checks will pass, which would make the error handling more annoying than helpful.

Yes, these aren't *important* problems per se, but they are still inconveniences to be aware of.

We now want to extend our library to model a [permutation group](https://en.wikipedia.org/wiki/Permutation_group), or just a representation of a bunch of permutations. In a permutation group, every permutation can be written as a sequence of compositions of base permutations. For example, the manipulations of the Rubik's Cube form a permutation group. Its base permutations are the six face rotations. Therefore, every possible state on the Rubik's cube can be reached from a combination of those face rotations.

<ContentImage src={rubiksCube} width="350" alt="The solved Rubik's cube" />

It follows that if you compose two elements in a permutation group, the resulting permutation will also be an element of that group.

A reasonable data structure for permutation groups looks like this.

```rust
pub struct PermGroup {
    base_permutation_length: usize,
    base_permutations: Vec<Permutation>,
}

impl PermGroup {
    pub fn new(
        base_permutation_length: usize,
        base_permutation_mappings: Vec<Vec<usize>>,
    ) -> Result<Self, &'static str> {
        // ... validate that each mapping is a valid
        // permutation of the given length
        // (remember that permutations can only be
        // composed if they have the same length)
        Ok(Self {
            base_permutation_length,
            base_permutations: base_permutation_mappings
                .into_iter()
                .map(Permutation::from_mapping)
                .collect::<Result<_, _>>()?,
        })
    }

    pub fn base_permutations(&self) -> &[Permutation] {
        &self.base_permutations
    }
}
```

Your *inner Ferris* awakens. With the annoyances of our last iteration freshly in memory, you ask yourself: can we perform the length check once during the creation of the permutation group, and avoid it entirely in our permutation composition function? Can we tweak our composition function to only operate on permutations from the same permutation group?

```rust
impl Permutation {
    pub fn from_mapping(mapping: Vec<usize>) -> Result<Self, &'static str> {
        // ... validate that `mapping` is a valid permutation
        Ok(Permutation(mapping.into_boxed_slice()))
    }

    pub fn compose_into(&self, b: &Permutation, into: &mut Permutation) {
        for i in 0..into.0.len() {
            unsafe {
                *into.0.get_unchecked_mut(i) = *self.0.get_unchecked(*b.0.get_unchecked(i));
            }
        }
    }

    pub fn compose(&self, b: &Permutation) -> Permutation {
        let mut result = Permutation(vec![0; self.0.len()].into_boxed_slice());
        self.compose_into(b, &mut result);
        result
    }
}
```

All of a sudden, we've opened up an unsafety hole! We implicitly assumed that the permutations to compose were from the same permutation group. This is not necessarily true—what if a library user composes two base permutations from different permutation groups? If the permutation lengths don't match, then `get_unchecked` will exhibit undefined behavior; this is clearly a problem! This operation is obviously nonsensical, but it does not change the fact that it is still *our* responsibility, as the crate author, that the safe functions we provide can never exhibit undefined behavior. If we wanted to validate our assumption, checking that a permutation is a member of a permutation group now becomes a very expensive operation; this is the "practical scenario" I mentioned beforehand.

We will analyze different approaches that ensure our library only permits permutations composition from the same permutation group. Each has their own trade-offs, but are all right answers for their own dedicated situations.

The simplest solution is to mark `compose_into` unsafe.

```rust
impl Permutation {
    // ...

    /// # Safety
    ///
    /// `self`, `b`, and `into` must all be from the same permutation group.
    pub unsafe fn compose_into(&self, b: &Permutation, into: &mut Permutation) {
        for i in 0..into.0.len() {
            unsafe {
                *into.0.get_unchecked_mut(i) = *self.0.get_unchecked(*b.0.get_unchecked(i));
            }
        }
    }
    // ...
}
```

If you don't care about unsafe—and there are valid reasons not to—then this might be what you want. That said, it's not always going to be this simple. Due to popular demand, you introduce the `ComposablePermutation` trait and implement it for `Permutation`. Your library users also want to implement permutation composition so they can take advantage of `PSHUFB`, a special hardware instruction which efficiently computes permutation composition, and use different permutation representations for their own data structures.

```rust
pub trait ComposablePermutation: Clone {
    fn from_mapping(mapping: Vec<usize>) -> Result<Self, &'static str>;

    /// # Safety
    ///
    /// `self`, `b`, and `into` must all be from the same permutation group.
    unsafe fn compose_into(&self, b: &Self, into: &mut Self);

    /// # Safety
    ///
    /// `self` and `b` must both be from the same permutation group.
    unsafe fn compose(&self, b: &Self) -> Self {
        let mut result = self.clone();
        unsafe { self.compose_into(b, &mut result) };
        result
    }
}
```

The consequences of using unsafe begin to show. Because our provided `Permutation` implements `ComposablePermutation`, and we have proved permutation composition from different permutation groups is unsound, `compose_into` must be made unsafe at the trait level. Rust doesn't allow us to only make `Permutation`'s implementation unsafe; either all implementors must be made unsafe, or none at all. For a library *about* permutation composition, we have now forced library users into unsafe for one of its most essential operations. Not just with `Permutation::compose_into`, but with all of their own implementations of `ComposablePermutation`.

*"That's completely unfair!"* You might say. *"This is a small and outrageously contagious edge condition that I don't care about. I'm going to mark this trait method safe anyways."* Well, the Rust community generally has a zero-tolerance stance on undefined behavior; the last time someone wanted to mark an unsound method safe, [it didn't end very well](https://github.com/ogxd/gxhash/issues/82#issuecomment-2257578785).

TODO: bridge into atomic ID

```rust
use std::sync::atomic::{AtomicU64, Ordering::Relaxed};

pub struct PermGroup {
    base_permutation_length: usize,
    base_permutations: Vec<Permutation>,
    id: u64,
}

static ID: AtomicU64 = AtomicU64::new(0);

impl PermGroup {
    pub fn new(
        base_permutation_length: usize,
        base_permutation_mappings: Vec<Vec<usize>>,
    ) -> Result<Self, &'static str> {
        // ... validate that each mapping is a valid
        // permutation of the given length
        let id = ID.fetch_add(1, Relaxed);
        Ok(Self {
            base_permutation_length,
            base_permutations: base_permutation_mappings
                .into_iter()
                .map(|mapping| Permutation(mapping.into_boxed_slice(), id))
                .collect(),
            id,
        })
    }

    pub fn base_permutations(&self) -> &[Permutation] {
        &self.base_permutations
    }

    pub fn id(&self) -> u64 {
        self.id
    }
}

pub struct Permutation(Box<[usize]>, u64);

impl Permutation {
    fn from_mapping(
        mapping: Vec<usize>,
        perm_group: &PermGroup,
    ) -> Result<Permutation, &'static str> {
        // ... validate that `mapping` is a valid permutation
        // that is a member of this group
        Ok(Permutation(mapping.into_boxed_slice(), perm_group.id()))
    }

    pub fn compose_into(
        &self,
        b: &Permutation,
        into: &mut Permutation,
    ) -> Result<(), &'static str> {
        if self.1 != b.1 || self.1 != into.1 {
            return Err("Permutations must come from the same group");
        }
        for i in 0..into.0.len() {
            unsafe {
                *into.0.get_unchecked_mut(i) = *self.0.get_unchecked(*b.0.get_unchecked(i));
            }
        }
        Ok(())
    }

    pub fn compose(&self, b: &Permutation) -> Result<Permutation, &'static str> {
        let mut result = Permutation(vec![0; self.0.len()].into_boxed_slice(), self.1);
        self.compose_into(b, &mut result)?;
        Ok(result)
    }
}
```

Use https://stackoverflow.com/questions/76847647/compile-time-tracking-of-value-owner-with-lifetimes

```rust
use std::marker::PhantomData;

pub struct PermGroup<Tok> {
    base_permutation_length: usize,
    base_permutations: Vec<Permutation<Tok>>,
}

impl<Tok> PermGroup<Tok> {
    pub fn new(
        base_permutation_length: usize,
        base_permutation_mappings: Vec<Vec<usize>>,
    ) -> Result<Self, &'static str> {
        // ... validate that each mapping is a valid
        // permutation of the given length
        // (remember that permutations can only be
        // composed if they have the same length)
        Ok(Self {
            base_permutation_length,
            base_permutations: base_permutation_mappings
                .into_iter()
                .map(Permutation::from_mapping)
                .collect::<Result<_, _>>()?,
        })
    }

    pub fn base_permutations(&self) -> &[Permutation<Tok>] {
        &self.base_permutations
    }
}

pub struct Permutation<Tok>(Box<[usize]>, PhantomData<Tok>);

impl<Tok> Permutation<Tok> {
    fn from_mapping(mapping: Vec<usize>) -> Result<Self, &'static str> {
        // ... validate that `mapping` is a valid permutation
        Ok(Permutation(mapping.into_boxed_slice(), PhantomData))
    }

    pub fn compose_into(&self, b: &Permutation<Tok>, into: &mut Permutation<Tok>) {
        for i in 0..into.0.len() {
            unsafe {
                *into.0.get_unchecked_mut(i) = *self.0.get_unchecked(*b.0.get_unchecked(i));
            }
        }
    }

    pub fn compose(&self, b: &Permutation<Tok>) -> Permutation<Tok> {
        let mut result = Permutation(vec![0; self.0.len()].into_boxed_slice(), PhantomData);
        self.compose_into(b, &mut result);
        result
    }
}

macro_rules! make_perm_group {
    ($($arg:expr),+ $(,)?) => {{
        struct InvariantToken;
        PermGroup::<InvariantToken>::new($($arg),+)
    }}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_permutation() {
        // let p1 = make_perm_group!(3, vec![vec![2, 0, 1]]).unwrap();
        // let p2 = make_perm_group!(4, vec![vec![1, 2, 0, 3]]).unwrap();
        // p1.base_permutations()[0].compose(&p2.base_permutations()[0]);
        let mut a = vec![];
        for args in [(3, vec![vec![2, 0, 1]]), (4, vec![vec![1, 2, 0, 3]])] {
            a.push(make_perm_group!(args.0, args.1).unwrap());
        }
        a[1].base_permutations()[0].compose(&a[0].base_permutations()[0]);
    }
}
```

generativity

```rust
use generativity::{Guard, Id};

pub struct PermGroup<'id> {
    base_permutation_length: usize,
    base_permutations: Vec<Permutation<'id>>,
}

impl<'id> PermGroup<'id> {
    pub fn new(
        base_permutation_length: usize,
        base_permutation_mappings: Vec<Vec<usize>>,
        guard: Guard<'id>,
    ) -> Result<Self, &'static str> {
        // ... validate that each mapping is a valid
        // permutation of the given length
        // (remember that permutations can only be
        // composed if they have the same length)
        let id = guard.into();
        Ok(Self {
            base_permutation_length,
            base_permutations: base_permutation_mappings
                .into_iter()
                // .map(Permutation::from_mapping)
                .map(|mapping| Permutation::from_mapping(mapping, id))
                .collect::<Result<_, _>>()?,
        })
    }

    pub fn base_permutations(&self) -> &[Permutation<'id>] {
        &self.base_permutations
    }
}

pub struct Permutation<'id>(Box<[usize]>, Id<'id>);

impl<'id> Permutation<'id> {
    fn from_mapping(mapping: Vec<usize>, id: Id<'id>) -> Result<Self, &'static str> {
        // ... validate that `mapping` is a valid permutation
        Ok(Permutation(mapping.into_boxed_slice(), id))
    }

    pub fn compose_into(&self, b: &Permutation<'id>, into: &mut Permutation<'id>) {
        for i in 0..into.0.len() {
            unsafe {
                *into.0.get_unchecked_mut(i) = *self.0.get_unchecked(*b.0.get_unchecked(i));
            }
        }
    }

    pub fn compose(&self, b: &Permutation<'id>) -> Permutation<'id> {
        let mut result = Permutation(vec![0; self.0.len()].into_boxed_slice(), self.1);
        self.compose_into(b, &mut result);
        result
    }
}
```

SCRATCH NOTES:

The fundamental problem is that the invariant of `Permutation` guarantees it is a valid permutation, but not that it is associated with a specific `PermGroup`.

What would really be nice is an *infallible* composition operation; one that we can guarantee is correct at the type level.
It's useful anytime you want to guarantee that two values come from or refer to the same source. Then give a list of bullet points that all need to be true to use generativity

We validate *upfront* that a set of permutations

BrandedVec

Does not use a closure

Generativity in the wild:
https://docs.rs/async-local/6.0.2/src/async_local/lib.rs.html#1-354


[Aria Desires's Master's thesis](https://raw.githubusercontent.com/Gankro/thesis/master/thesis.pdf)
"Hacking Generativity into Rust", right before she says "we really don’t recommend doing this".

Generativity is a limited system that can solve some of the problems usually re-served for dependent typing. Rust was not designed to support this