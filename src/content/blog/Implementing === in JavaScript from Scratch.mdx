---
url: implementing-strict-equality-in-javascript-from-scratch
description: Object reference comparsion on Chromium<104
---
{/* cspell:ignore xattr extensios */}

import ContentImage from "../../components/ContentImage.astro";
import heapProfiler from "../../assets/blog/implementing-strict-equality-in-javascript-from-scratch/heap-profiler.png";

Yes, I know exactly what you're thinking.

> Reinventing the wheel? That's the most moronic idea I've ever heard since that guy who wanted to invade Russia in the winter.

And you're not wrong. For all practical purposes, this blog is pointless. If you were looking for a small code snippet to show off on your quirky little website, I hate to break it to you, but what you're about to read is so obscenely nutty that it only works on a legacy version of Chromium as an extension running millions of times slower.

The strict equality operator in JavaScript (===) compare two values for object equality. As you probably already know, this operator tests reference equality for non-primitive JavaScript values. In effect, because `{ foo: 42 } === { foo: 42 }` is `false`, implementing this functionality becomes much more interesting. I'm not talking about the obvious ways. Various other built-ins make object reference comparison trivial.

```js
let obj1 = { foo: 42 };
let obj2 = obj1;

Object.is(obj1, obj2) && console.log("same");
[obj1].includes(obj2) && console.log("same");
switch (obj1) {
  case obj2:
    console.log("same");
}
new Set().add(obj1).has(obj2) && console.log("same");
```

We will implement this basic operation on a far lower level. But what does that mean, and how else could JavaScript differentiate two objects that hold the same data? [Surface level research](https://stackoverflow.com/questions/1997661/unique-object-identifier-in-javascript) yields nothing. Let's take a deep dive.

A few weeks ago I was looking into the Chromium DevTools heap profiler for a separate [blog](../true-private-state-in-javascript-a-chromium-rabbit-hole/) post of mine. I keenly noticed that the heap profiler distinguishes JavaScript objects by memory location. I might be able to utilize that to my advantage, thus revealing a glimmer of light at the end of the tunnel.

```js
let obj1 = { foo: 42 };
let obj2 = { foo: 42 };
```
<ContentImage src={heapProfiler} alt="The heap profiler demonstrating that two objects have different memory locations" />

This isn't useful if there isn't a way to access these memory locations programmatically. Fortunately, there exists a standardized JavaScript API that fits my needs called the [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol), or CDP. It allows for direct inspection into the JavaScript runtime on Blink-based browsers. Sure enough, Chrome DevTools uses this protocol for the heap profiler.

The original question still stands; how does JavaScript access the CDP? The documentation endorses two means of access. First, open [devtools-on-devtools](https://stackoverflow.com/questions/12291138/how-do-you-inspect-the-web-inspector-in-chrome/12291163#12291163) and interface with the CDP like so.

```js
let Main = await import('./devtools-frontend/front_end/entrypoints/main/main.js');
await Main.MainImpl.sendOverProtocol('Emulation.setDeviceMetricsOverride', {
  mobile: true,
  width: 412,
  height: 732,
  deviceScaleFactor: 2.625,
});
```

This requires explicit access to DevTools and some setup, meaning it wouldn't plainly work on a website. The alternative option was the `chrome.debugger` API within a Chrome extension. Although this would be a bit harder to work with, it was actually programmatic and eventually the option I chose.

I hacked up a quick Chrome extension but was surprised when my testing errored with the following message.

```json
{"code":-32601,"message":"'HeapProfiler.enable' wasn't found"}
```

What's going on here? As it turns out, [internal documentation](https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/public/devtools_protocol/#security-considerations) reveals that specific Protocol Domains are restricted for security reasons.

> However, since the protocol is also exposed to chrome extensions through chrome.debugger API, the backend implements additional access control in some of the methods to prevent extensios form accessing file system or otherwise escaping the sandbox. These restrictions are not extended to other types of clients.

[Here](https://chromium.googlesource.com/v8/v8/+/c42e620355453fc0510b06e089ca7d92598bd54f%5E%21/) is the v8 commit that adds these restrictions, dating May 2022 and Chromium version v103. You guessed what's going to happen next. The solution to our dilemma, of course, is to time travel.

[Archives](https://www.slimjet.com/chrome/google-chrome-old-version.php) of older versions of Chrome exist online. However, I'm wary of downloading unknown files from the Internet. Instead, I installed an official Chromium build from source following their [guide](https://www.chromium.org/getting-involved/download-chromium/#downloading-old-builds-of-chrome-chromium). Note that you may have to run `/usr/bin/xattr -cr /Applications/Chromium.app` on an M1 Mac to fix broken metadata preventing Chromium from launching.

https://chromium.googlesource.com/chromium/src/+/8f07eaff87947a2e93214de2695de8052119180b Chromium version v111

https://tc39.es/ecma262/multipage/abstract-operations.html#sec-isstrictlyequal

https://stackoverflow.com/questions/5276915/do-common-javascript-implementations-use-string-interning

https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-UnserializableValue

```js
function primitiveEquality(p1, p2) {
  if (p1.subtype) {
    p1.type = p1.subtype;
  }
  if (p2.subtype) {
    p2.type = p2.subtype;
  }
  if (!stringEquality(p1.type, p2.type)) {
    return false;
  }
  if (stringEquality(p1.type, "number")) {
    if (
      stringEquality(p1.description, "NaN") ||
      stringEquality(p2.description, "NaN")
    ) {
      return false;
    }
    if (
      (stringEquality(p1.description, "0") &&
        stringEquality(p2.description, "-0")) ||
      (stringEquality(p1.description, "-0") &&
        stringEquality(p2.description, "0"))
    ) {
      return true;
    }
    if (p1.unserializableValue || p2.unserializableValue) {
      return stringEquality(p1.description, p2.description);
    }
    return !(p1.value - p2.value);
  }
  if (stringEquality(p1.type, "null") || stringEquality(p1.type, "undefined")) {
    return true;
  }
  if (stringEquality(p1.type, "bigint")) {
    return stringEquality(p1.description, p2.description);
  }
  if (stringEquality(p1.type, "string")) {
    return stringEquality(p1.value, p2.value);
  }
  if (stringEquality(p1.type, "boolean")) {
    return !(p1.value - p2.value);
  }
  throw new Error("Unsupported primitive type");
}
```