---
description: Allocating heap memory on the screen
---
If you've kept up with my blog, you might know that my recent *"street-cred"* has been messing around with "[corruption art](../turning-image-corruption-into-art)." I can't help it. Stuff like this is always so fascinating to me.

Some context would be in order. Two years ago, I made [NAND](https://nand.arhan.sh), a 16-bit computer made entirely from NAND gates emulated on the web. NAND features its own custom CPU architecture, virtual machine, programming language, compiler, and IDE, and it is based on the Jack-VM-Hack platform specified in the [Nand to Tetris](https://www.nand2tetris.org/) course. Here's (single-player) pong!

<ContentVideo src={pong} alt="Pong on NAND" />

Now, I have many [wonderful things](https://github.com/ArhanChaudhary/NAND/blob/main/README.md) to talk about with NAND, but we're not going to be focusing on that. A few weeks ago during the height of my midterms I had a crazy idea: what if we allocated memory on the *screen* instead of on the *heap*?

To understand what that means, let's consider this program written in NAND's custom programming language.

```java
class Main {
    function void main() {
        var int length;
        var Array a;
        let length = Keyboard.readInt("How much memory? ");
        let a = Array.new(length);
    }
}
```

The compiler stores the local variables of a function in a memory region called the stack. Everything on the stack must have a size that is known at compile time so the compiler knows how much memory to reserve for it. However, the compiler has no way of knowing how much memory is required to store the array `a`â€”it's a dynamic amount only known at run time. The contemporary solution is to use a *memory allocator*, a component of the operating system that you can ask to give you an arbitrary amount of memory and returns a pointer to a chunk of that memory. The memory allocator looks for memory in a memory region called the heap.

After you run the above program, the NAND memory allocator does this:

<Typst code={Memory} props={{ "style": "max-height: 500px", preserveAspectRatio: "xMidYMid meet", width: null, height: null }} />

The NAND memory allocator source code [looks obtuse](https://github.com/ArhanChaudhary/NAND/blob/2c6c52f733970e48ad9cba211ce73b42b43fb2b4/src/os/Memory.jack#L31), but all it's really doing is traversing a linked list of memory blocks and returning the first one with enough memory to satisfy the allocation request. It can undoubtedly be made [more efficient](https://en.wikipedia.org/wiki/Memory_management#Implementations). The screen is stored as a bitmap of 512 (length) * 256 (width) = 131072 pixels in its own dedicated memory region. There are no colors; a 0 means black and a 1 means green. To *allocate memory on the screen instead of the heap* means to tell the memory allocator to treat the screen memory region as the heap memory region.

What makes this so interesting is the fact that NAND has no trap instructions, no hardware interrupts, and no concept of a kernel mode. Universally among modern computers, if you try to read or write memory that belongs to another process or memory region, the operating system will correctly trigger a segmentation fault and terminate your program. But NAND gives every program full reign to modify any part of the computer memory, meaning logically invalid memory operations are allowed, permitting strange yet fascinating undefined behavior.

Now to actually do it.

`Memory.jack`

```java
class Memory {
    static Array ptr;
    static int offset; // [!code ++]

    /** Initializes the class. */
    function void init() { // [!code --]
    function void init(int offset_) { // [!code ++]
        let ptr = 0;
        let ptr[2048] = 14334; // [!code --]
        let ptr[2049] = 16384; // [!code --]
        let offset = offset_; // [!code ++]
        let ptr[offset] = 24574 - offset; // [!code ++]
        let ptr[offset + 1] = 24576; // [!code ++]
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var Array segment;
        var int length;
        if (size < 0)
            do Sys.error(5);
        let segment = 2048; // [!code --]
        let segment = offset; // [!code ++]
        ...
```

*(This is NAND's custom programming language; you can read it like Java)*

In terms of modifying the memory allocator, this is all that is needed! The memory allocator normally starts at memory address 2048 and initializes its linked list data structure over there, the start of the heap memory region. This modification tells the memory allocator to start at the integer `offset_` provided as an argument during initialization.

`Sys.jack`

```java
class Sys {

    /** Performs all the initializations required by the OS. */
    function void init() {
        do Memory.init(); // [!code --]
        do Memory.init(16384); // [!code ++]
        do Math.init();
        do Screen.init();
        do Screen.clearScreen(); // [!code --]
        do Output.init();
        do Main.main();
        do Sys.halt();
    }
    ...
```

The entrypoint of every NAND program is hardcoded to be `Sys.init`. When this function is called, it initializes the operating system libraries, runs `Main.main` to execute the program, and runs `Sys.halt` to terminate the program. It's analogous to the [`_start`](http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html) entrypoint on Linux. We change `Memory.init` to take as input the start of the screen memory region, 16384, so the memory allocator allocates memory on the screen. We have to disable the routine that automatically clears the screen at the start of every program because it zeros out the metadata that was just configured by `Memory.init` and renders the memory allocator unusable.

With that out of the way, let's run it on a hello world program and see what happens!

`Main.jack`

```java
class Main {
    function void main() {
        do Output.printString("Hello world!");
    }
}
```

<ContentImage src={helloworld} width={null} alt="A screen with heap memory and hello world printed" />

Great, there's our heap! If you look at the top left corner of the screen, you'll see "Hello World!". Printing the text to the screen *overwrote* some of the heap memory data! It looks wonderful, but this program is actually relatively uninteresting as it immediately terminates afterwards. Can we run the pong program initially shown with our modified, silly memory allocator? We need to do two more things.

`Sys.jack`

```java
    ...
    /** Halts the program execution. */
    function void halt() {
        // hardware-specific flag to tell the computer runtime to stop // [!code --]
        do Memory.poke(24576, 32767); // [!code --]
        while (~false) {} // [!code --]
    }
    ...
```

First, whenever a NAND program is finished or the operating system detects something logically invalid like divide by zero, the operating system calls `Sys.halt` to terminate the program and enter an infinite loop. We don't want our program to terminate for any reason, so we simply delete this code.

Second, we add a prompt before running the program that asks the user to enter an integer offset to add to the screen region memory address (i.e `Memory.init(16384 + offset)`).  We do this because allocating heap data at the same place on the screen would produce the same results every time. It's nice (as you will soon see) to introduce variety in the results. The code at this point doesn't feel necessary to explain in full detail, so I've omitted it.

We're off to the races. I spent a few days playing around with memory offsets and want to showcase the most interesting results. First up is pong at offset 914:

<ContentVideo src={offset914} alt="Corrupted pong with memory offset 914" />

There's a lot to unpack here! You might have noticed that the ball appears to *teleport*â€”this is because it is literally overwriting the bits that control its position on the screen while in motion. The ball then overwrites the *paddle's* position bits to the top of the screen and height bits to approximately three times as tall. Despite the extensive memory corruption, why did the pong program still have some semblance of being able to run? NAND uses the [Harvard architecture](https://en.wikipedia.org/wiki/Harvard_architecture), which means that the program memory is stored separately from the instruction memory. The instruction memory can only be written to once when loading a program; it is read-only during its execution. So, the logic to move the paddle around and bounce the ball will always still exist.

Next, here is pong at offset -10:

<ContentVideo src={offsetMinus10} alt="Corrupted pong with memory offset -10" />

The ball is doing some spooky things hereâ€”it's supposed to move in a straight line as a reminder ðŸ‘». The main takeaway with this program is that it somehow *restarts itself* at the end. Why this happens is simple: the program executed an instruction that sets the [program counter](https://en.wikipedia.org/wiki/Program_counter)'s value to 0, effectively telling the program to jump to the first instruction and start over.

<ContentVideo src={cthulu} alt="Corrupted pong with the entire screen exploding" />

Bam, what happened here? I would be lying if I said I knew the exact details, but what probbaly happened is the program executed an instruction to jump to some random part in the instruction memory. At that point, all bets what is supposed to happen are off: the abstraction of function calls and the program logic flow is destroyed. The processor might as well just be executing random instructions and interpreting random noise as memory. You invoked *undefined behavior*. NAND invoked *Cthulhu*.

I don't have much to say about the next few videos, but you should give each one a moment to marvel at what is actually happening.

Here is pong at offset 6:

<ContentVideo src={offset6} alt="Corrupted pong with memory offset 6" />

Here is pong with extra modifications that I don't remember:

<ContentVideo src={blinking} alt="Corrupted pong with a blinking paddle" />

Here is pong at offset 577:

<ContentVideo src={offset577} alt="Corrupted pong with memory offset 577" />

Here is pong at offset 777:

<ContentVideo src={offset777} alt="Corrupted pong with memory offset 777" />

This last one is my personal favorite because of how it long it lasts before restarting the program. Try to play pong all the way to the end; it's a fun challenge!

I invite you to try out this program for yourself at [NAND](https://nand.arhan.sh/)'s website. To run it, click "Load example program", select "CorruptedPong", and click "Start". Note that your results will not always be deterministic because the program memory persists when a program is manually reset. If you want the same behavior every time, or if you want to reproduce the results of the offsets in my videos, make sure to first clear the program memory by clicking "Dec" on the memory view and selecting "Clr".

So, yeah. Your takeaway should be that this could technically happen the next time you read one byte of memory out of bounds in C. Until next time!
